<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="stylesheet" href="css/leaflet.css" />
    <link rel="stylesheet" href="css/L.Control.Layers.Tree.css" />
    <link rel="stylesheet" href="css/qgis2web.css" />
    <link rel="stylesheet" href="css/fontawesome-all.min.css" />
    <link rel="stylesheet" href="css/leaflet.photon.css" />
    <link rel="stylesheet" href="css/leaflet-measure.css" />
    <style>
      html,
      body,
      #main-container {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        display: flex;
        overflow: hidden;
      }
      /* Full-page animated background (subtle, professional) */
      #page-bg{
        position:fixed;
        inset:0;
        z-index:-2; /* sit behind canvas layers */
        pointer-events:none;
        background-image: url('images/bg-night.jpg'),
          radial-gradient(circle at 10% 20%, rgba(99,102,241,0.06), transparent 12%),
          radial-gradient(circle at 90% 80%, rgba(34,197,94,0.04), transparent 12%),
          linear-gradient(120deg, #071428 0%, #072a3a 40%, #0b486b 100%);
        background-size: cover, 180% 180%, 220% 220%, 400% 400%;
        background-position: center, 0% 0%, 100% 100%, 50% 50%;
        background-repeat: no-repeat;
        filter: blur(10px) saturate(120%);
        mix-blend-mode: normal;
        transition: opacity 300ms ease;
        opacity: 0.98;
        animation: pageBgShift 18s ease-in-out infinite;
      }
      @keyframes pageBgShift{
        0%{ background-position: 0% 10%, 100% 90%, 40% 60%; }
        50%{ background-position: 30% 40%, 70% 60%, 60% 40%; }
        100%{ background-position: 0% 10%, 100% 90%, 40% 60%; }
      }
      @media (prefers-reduced-motion: reduce){
        #page-bg{ animation: none; filter: blur(6px); }
        #bg-stars, #bg-particles { display: none !important; }
      }

      /* Canvas layers for animated elements */
      #bg-stars, #bg-particles{
        position:fixed;
        inset:0;
        width:100%;
        height:100%;
        z-index:-1; /* above page-bg but below UI */
        pointer-events:none;
        display:block;
      }
      #sidebar {
        width: 300px;
        height: 100%;
        position: relative;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        /* stronger glass effect: more transparent, blurred backdrop */
        background: rgba(255,255,255,0.36);
        -webkit-backdrop-filter: blur(10px) saturate(140%);
        backdrop-filter: blur(10px) saturate(140%);
        border-right: 1px solid rgba(255,255,255,0.14);
        box-shadow: 0 8px 32px rgba(16,24,40,0.06);
        z-index: 1000;
      }
      /* Keep sidebar content above animated background */
      #sidebar > * {
        position: relative;
        z-index: 2;
      }

      /* 3D Animated Canvas Background */
      #sidebar-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
        opacity: 0.75;
      }

      /* Subtle overlay to keep text readable */
      #sidebar::after {
        content: "";
        position: absolute;
        inset: 0;
        z-index: 1;
        pointer-events: none;
        background: linear-gradient(180deg, rgba(255,255,255,0.45), rgba(255,255,255,0.15));
        mix-blend-mode: normal;
      }

      /* Reduced-motion fallback */
      @media (prefers-reduced-motion: reduce) {
        #sidebar-canvas { display: none !important; }
      }
      #map {
        flex-grow: 1;
        height: 100%;
      }
      .sidebar-header {
        padding: 25px 20px;
        background: linear-gradient(135deg, #0078a8 0%, #005a7e 100%);
        color: white;
        text-align: center;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .sidebar-header h2 {
        margin: 0;
        font-size: 22px;
        font-weight: 700;
        font-family: "Open Sans", sans-serif;
        letter-spacing: 0.5px;
      }
      .sidebar-section {
        padding: 20px 15px;
        border-bottom: none; /* remove visual segmentation */
      }
      .sidebar-section h3 {
        margin: 0 0 15px 0;
        font-size: 13px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        font-weight: 700;
        font-family: "Open Sans", sans-serif;
      }
      .control-container {
        background: #fdfdfd;
        border-radius: 8px;
        border: none; /* make controls blend into sidebar */
        overflow: hidden;
      }
      /* SEAMLESS INTEGRATION - Blend into sidebar base */
      #layers-control {
        padding: 0 !important;
        margin: 0 !important;
      }
      #layers-control .leaflet-control-layers,
      #layers-control .leaflet-control-layers-list,
      #layers-control .leaflet-control-layers-expanded,
      #layers-control .leaflet-layerstree-children,
      #layers-control .leaflet-layerstree-header,
      #layers-control .leaflet-layerstree-node {
        padding-left: 0 !important;
        margin-left: 0 !important;
        border: none !important;
        box-shadow: none !important;
        background: transparent !important;
      }
      /* Hide ONLY the specific Leaflet UI ornaments */
      #layers-control span.leaflet-layerstree-header-pointer,
      #layers-control .leaflet-layerstree-spacer,
      #layers-control .leaflet-layerstree-nevershow,
      .leaflet-control-layers-toggle {
        display: none !important;
      }
      .leaflet-layerstree-node {
        padding: 6px 8px !important; /* Reduced vertical padding for compactness */
        margin: 0 !important;
        border-radius: 0;
        transition: all 0.2s ease;
        cursor: pointer;
        display: flex !important;
        align-items: center;
        width: 100% !important;
        box-sizing: border-box;
        border-bottom: none; /* remove subtle divider */
      }
      .leaflet-layerstree-node:hover {
        background: #fdfdfd;
      }
      .leaflet-layerstree-header label {
        display: flex !important;
        align-items: center !important;
        width: 100% !important;
        cursor: pointer !important;
        font-size: 14px !important;
        color: #333 !important;
        font-weight: 600 !important;
        margin: 0 !important;
        padding: 0 !important;
        visibility: visible !important;
        display: flex !important;
      }
      .leaflet-layerstree-header-name {
        display: inline-block !important;
        visibility: visible !important;
        margin-left: 10px !important;
        white-space: normal !important; /* Allow wrapping */
        word-break: break-all !important; /* Break long words */
        max-width: 220px !important; /* Slightly larger width so names are visible */
        line-height: 1.4;
        padding: 4px 0;
      }
      .layer-color-picker-wrapper {
        display: flex;
        align-items: center;
        margin-right: 8px;
        cursor: pointer;
      }
      .layer-color-picker {
        width: 20px;
        height: 20px;
        padding: 0;
        border: 2px solid #fff;
        border-radius: 50%;
        cursor: pointer;
        outline: none;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        -webkit-appearance: none;
        appearance: none;
        background: none;
      }
      .layer-color-picker::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      .layer-color-picker::-webkit-color-swatch {
        border: none;
        border-radius: 50%;
      }
      /* Custom Checkbox and Radio - ABSOLUTE START */
      .leaflet-control-layers input[type="checkbox"],
      .leaflet-control-layers input[type="radio"] {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border: 2px solid #0078a8;
        border-radius: 4px;
        margin: 0 12px 0 10px !important; /* Added left margin */
        position: relative;
        cursor: pointer;
        background: #fff;
        transition: all 0.2s;
        flex-shrink: 0;
        display: inline-block !important;
      }
      .leaflet-control-layers input[type="radio"] {
        border-radius: 50%;
      }
      .leaflet-control-layers input[type="checkbox"]:checked {
        background: #0078a8;
        border-color: #0078a8;
      }
      .leaflet-control-layers input[type="checkbox"]:checked::after {
        content: "\f00c";
        font-family: "Font Awesome 5 Free";
        font-weight: 900;
        color: white;
        font-size: 11px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .leaflet-control-layers input[type="radio"]:checked {
        border-color: #0078a8;
      }
      .leaflet-control-layers input[type="radio"]:checked::after {
        content: "";
        width: 10px;
        height: 10px;
        background: #0078a8;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      /* Dynamic Layer Removal UI */
      .layer-row-container {
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 100%;
        overflow: hidden;
        padding-right: 2px;
      }
      .layer-label-top {
        display:flex;
        align-items:center;
        justify-content:space-between;
        width:100%;
      }
      .layer-controls {
        display:flex;
        align-items:center;
        gap:8px;
      }
      /* Styled range (slider) */
      .layer-controls input[type="range"]{
        width:120px;
        height: 10px;
        -webkit-appearance: none;
        appearance: none;
        background: linear-gradient(90deg, var(--track-color, #0078a8) 50%, #e6e6e6 50%);
        border-radius: 8px;
        outline: none;
        padding: 0;
        margin: 0 6px 0 0;
        vertical-align: middle;
        box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
        transition: box-shadow 160ms ease, background 160ms ease;
      }
      .layer-controls input[type="range"]:focus{ box-shadow: inset 0 1px 3px rgba(0,0,0,0.08), 0 0 0 4px rgba(0,120,168,0.06); }
      .layer-controls input[type="range"]::-webkit-slider-runnable-track{
        height: 10px;
        border-radius: 8px;
      }
      .layer-controls input[type="range"]::-webkit-slider-thumb{
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(180deg,#fff,#f5f7fb);
        border: 3px solid var(--thumb-border, rgba(0,0,0,0.12));
        box-shadow: 0 2px 6px rgba(16,24,40,0.12);
        margin-top: -4px; /* center thumb visually */
      }
      .layer-controls input[type="range"]::-moz-range-track{
        height: 10px;
        border-radius: 8px;
        background: transparent;
      }
      .layer-controls input[type="range"]::-moz-range-thumb{
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(180deg,#fff,#f5f7fb);
        border: 3px solid var(--thumb-border, rgba(0,0,0,0.12));
        box-shadow: 0 2px 6px rgba(16,24,40,0.12);
      }
      /* Compact, styled number input (smaller width as requested) */
      .layer-controls input[type="number"]{
        width:34px;
        padding:2px 4px;
        border-radius:8px;
        border:1px solid #e0e5ea;
        background: linear-gradient(180deg,#ffffff,#f7fbff);
        text-align:center;
        font-weight:700;
        vertical-align: middle;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.6), 0 1px 2px rgba(16,24,40,0.04);
        transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
      }
      .layer-controls input[type="number"]:focus{
        transform: translateY(-1px);
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.6), 0 4px 14px rgba(7,90,120,0.08);
      }
      .layer-label-group {
        display: flex;
        align-items: center;
        flex-grow: 1;
        overflow: hidden;
      }
      .remove-layer-btn {
        color: #ff4d4d;
        cursor: pointer;
        padding: 5px 8px;
        font-size: 14px;
        transition: all 0.2s;
        opacity: 0.6;
        margin-left: auto;
      }
      .remove-layer-btn:hover {
        opacity: 1;
        transform: scale(1.2);
      }
      /* Legend Alignment */
      .leaflet-layerstree-header img {
        margin-right: 10px !important;
        max-height: 22px !important;
        vertical-align: middle !important;
        border-radius: 2px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      /* Sidebar Toggle for Mobile */
      #sidebar-toggle {
        display: none;
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1100;
        background: #0078a8;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 4px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
      @media (max-width: 768px) {
        #sidebar {
          position: absolute;
          left: -320px;
          transition: left 0.3s ease;
        }
        #sidebar.active {
          left: 0;
        }
        #sidebar-toggle {
          display: block;
        }
      }
      /* Upload UI Styling */
      .upload-control {
        padding: 5px;
        font-family: "Open Sans", sans-serif;
      }
      .upload-field {
        margin-bottom: 10px;
      }
      .custom-file-upload {
        display: block;
        padding: 12px;
        cursor: pointer;
        background: #f8f9fa;
        border: 1px dashed #ccd;
        border-radius: 6px;
        text-align: center;
        font-size: 13px;
        font-weight: 600;
        color: #0078a8;
        transition: all 0.3s ease;
      }
      .custom-file-upload:hover {
        background: #eef7fb;
        border-color: #0078a8;
      }
      .custom-file-upload i {
        margin-right: 8px;
        font-size: 16px;
      }
      .upload-field input[type="file"] {
        display: none;
      }
      .file-name {
        display: block;
        font-size: 11px;
        color: #888;
        margin-top: 6px;
        text-align: center;
      }
      .upload-control button {
        width: 100%;
        padding: 12px;
        background: #0078a8;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 700;
        font-size: 14px;
        margin-top: 10px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 10px rgba(0, 120, 168, 0.2);
      }
      .upload-control button:hover {
        background: #005a7e;
        transform: translateY(-1px);
        box-shadow: 0 6px 15px rgba(0, 120, 168, 0.3);
      }
      .upload-control .status {
        margin-top: 15px;
        font-size: 12px;
        color: #666;
        text-align: center;
        font-style: italic;
      }
      /* Professional 3D Wave/Aurora Background for Control Panel (React Bits inspired) */
      #layers-control .leaflet-control-layers {
        position: relative;
        overflow: visible;
        background: transparent !important;
      }
      #layers-control .leaflet-control-layers::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 12px;
        z-index: 0;
        pointer-events: none;
        background: 
          linear-gradient(135deg, 
            rgba(99, 102, 241, 0.15) 0%, 
            rgba(139, 92, 246, 0.12) 25%,
            rgba(59, 130, 246, 0.15) 50%,
            rgba(14, 165, 233, 0.12) 75%,
            rgba(6, 182, 212, 0.15) 100%
          );
        background-size: 400% 400%;
        animation: aurora-wave 12s ease-in-out infinite;
        filter: blur(20px);
        opacity: 0.8;
      }
      #layers-control .leaflet-control-layers::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 12px;
        z-index: 1;
        pointer-events: none;
        background: 
          radial-gradient(circle at 20% 30%, rgba(99, 102, 241, 0.2), transparent 40%),
          radial-gradient(circle at 80% 70%, rgba(14, 165, 233, 0.18), transparent 40%),
          radial-gradient(circle at 50% 50%, rgba(139, 92, 246, 0.15), transparent 50%),
          linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
        background-size: 200% 200%, 250% 250%, 300% 300%, 100% 100%;
        animation: aurora-orbs 15s ease-in-out infinite;
        -webkit-backdrop-filter: blur(8px) saturate(150%);
        backdrop-filter: blur(8px) saturate(150%);
        box-shadow: 
          inset 0 1px 0 rgba(255,255,255,0.1),
          inset 0 -1px 0 rgba(0,0,0,0.05),
          0 8px 32px rgba(99, 102, 241, 0.1);
      }
      /* Ensure layer nodes render above the animated background */
      #layers-control .leaflet-control-layers .leaflet-layerstree-node,
      #layers-control .leaflet-control-layers .leaflet-layerstree-header {
        position: relative;
        z-index: 2;
      }
      @keyframes aurora-wave {
        0% {
          background-position: 0% 50%;
          transform: scale(1) rotate(0deg);
        }
        33% {
          background-position: 50% 80%;
          transform: scale(1.05) rotate(2deg);
        }
        66% {
          background-position: 100% 20%;
          transform: scale(0.98) rotate(-1deg);
        }
        100% {
          background-position: 0% 50%;
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes aurora-orbs {
        0% {
          background-position: 0% 0%, 100% 100%, 50% 50%, 0% 0%;
        }
        25% {
          background-position: 40% 30%, 60% 70%, 30% 70%, 0% 0%;
        }
        50% {
          background-position: 100% 50%, 0% 50%, 70% 30%, 0% 0%;
        }
        75% {
          background-position: 60% 70%, 40% 30%, 50% 60%, 0% 0%;
        }
        100% {
          background-position: 0% 0%, 100% 100%, 50% 50%, 0% 0%;
        }
      }
      /* Toggle Pills */
      .toggle-container {
        display: flex;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50px;
        padding: 4px;
        margin: 15px 0;
        position: relative;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(5px);
      }
      .toggle-option {
        flex: 1;
        padding: 10px 0;
        text-align: center;
        color: #fff;
        font-weight: 600;
        font-size: 13px;
        position: relative;
        z-index: 1;
        transition: color 0.3s;
      }
      .toggle-option.active {
        color: #fff;
      }
      .toggle-slider {
        position: absolute;
        width: 50%;
        height: calc(100% - 8px);
        background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
        border-radius: 50px;
        top: 4px;
        left: 4px;
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        box-shadow: 0 4px 15px rgba(236, 72, 153, 0.4);
      }
      .toggle-container.unique-active .toggle-slider {
        left: calc(50% - 4px);
      }
      .sidebar-group-hidden {
        display: none !important;
      }
    </style>
    <title>Manhole Locations — Interactive Map</title>
  </head>
  <body>
    <div id="page-bg" aria-hidden="true"></div>
    <canvas id="bg-stars" aria-hidden="true"></canvas>
    <canvas id="bg-particles" aria-hidden="true"></canvas>
    <button id="sidebar-toggle"><i class="fas fa-bars"></i> Menu</button>
    <div id="main-container">
      <div id="sidebar">
        <canvas id="sidebar-canvas" aria-hidden="true"></canvas>
        <div class="sidebar-header">
          <h2>Manhole Locations</h2>
        </div>

        <div class="sidebar-section">
          <h3>Layers</h3>
          <div class="toggle-container" id="view-toggle">
            <div class="toggle-slider"></div>
            <div class="toggle-option active" data-view="total">Total</div>
            <div class="toggle-option" data-view="unique">Unique</div>
          </div>
          <div id="layers-control"></div>
        </div>

        <div class="sidebar-section">
          <h3>Upload Data</h3>
          <div class="upload-control">
            <div class="upload-field">
              <label for="csvFile" class="custom-file-upload">
                <i class="fas fa-file-csv"></i> Select CSV File
              </label>
              <input type="file" id="csvFile" accept=".csv" />
              <span id="csv-name" class="file-name">No file selected</span>
            </div>
            <div class="upload-field">
              <label for="imgFiles" class="custom-file-upload">
                <i class="fas fa-images"></i> Select Images
              </label>
              <input type="file" id="imgFiles" accept="image/*" multiple />
              <span id="img-count" class="file-name">0 images selected</span>
            </div>
            <button id="uploadBtn">
              <i class="fas fa-cloud-upload-alt"></i> Add to Map
            </button>
            <div id="uploadStatus" class="status"></div>
          </div>
        </div>
      </div>
      <div id="map"></div>
    </div>
    <script src="js/qgis2web_expressions.js"></script>
    <script src="js/leaflet.js"></script>
    <script src="js/L.Control.Layers.Tree.min.js"></script>
    <script src="js/leaflet.rotatedMarker.js"></script>
    <script src="js/leaflet.pattern.js"></script>
    <script src="js/leaflet-hash.js"></script>
    <script src="js/Autolinker.min.js"></script>
    <script src="js/rbush.min.js"></script>
    <script src="js/labelgun.min.js"></script>
    <script src="js/labels.js"></script>
    <script src="js/leaflet.photon.js"></script>
    <script src="js/leaflet-measure.js"></script>
    <script src="data/ManholeCovers_1.js"></script>
    <script src="data/MCSKPZones_2.js"></script>
    <script>
      // Global variables
      var map, lay, hash, autolinker, zoomControl, measureControl, bounds_group;
      var layer_ManholeCovers_Inside, layer_ManholeCovers_Outside, layer_MCSKPZones_2;
      var overlaysTree = [], labels = [], totalMarkers = 0;
      
      // Data arrays & FeatureCollections (Global for accessibility)
      var totalInside = [], totalOutside = [], uniqueInside = [], uniqueOutside = [];
      var json_ManholeCovers_Inside, json_ManholeCovers_Outside, json_UniqueInside, json_UniqueOutside;
      var boundaryPolygons = [], polyBboxes = [], uniqueFeatures = [], coordMap = {};
      
      // Defaults for manhole points
      var defaultManholeColor = '#b7484b';
      var defaultManholeRadius = 5;
      var colorPalette = ["#28a745", "#007bff", "#e83e8c", "#fd7e14", "#6f42c1", "#20c997", "#ffc107", "#17a2b8"];
      var colorIndex = 0;

      // Color State (Stores user preference per mode)
      var modeColors = {
        total: {
          ManholeCovers_Inside: '#b7484b',
          ManholeCovers_Outside: '#555555'
        },
        unique: {
          ManholeCovers_Inside: '#00D1FF',
          ManholeCovers_Outside: '#0084A1'
        }
      };

      document.addEventListener('DOMContentLoaded', function() {
        // All initialization code goes here
        initApp();
      });



      function initApp() {
        console.log("Initializing App...");
        try {

      // Global function to change dynamic layer color
      window.changeLayerColor = function (layerId, newColor) {
        var targetLayer = null;
        for (var j = 0; j < overlaysTree.length; j++) {
          if (overlaysTree[j].id === layerId) {
            targetLayer = overlaysTree[j].layer;
            break;
          }
        }
        if (targetLayer) {
          try {
            targetLayer.eachLayer(function (l) {
              if (l.setStyle) {
                l.setStyle({ fillColor: newColor, color: l.options && l.options.color ? l.options.color : '#000' });
              }
            });
          } catch (err) {
            if (typeof targetLayer.setStyle === 'function') {
              targetLayer.setStyle({ fillColor: newColor });
            }
          }
        }
        
        // Save to state
        var toggle = document.getElementById('view-toggle');
        var currentMode = (toggle && toggle.classList.contains('unique-active')) ? 'unique' : 'total';
        if (modeColors[currentMode]) {
          modeColors[currentMode][layerId] = newColor;
        }

        // also update the UI slider/number/colorpicker visuals
        try { 
          setSliderColorForLayer(layerId, newColor); 
          var cpElem = document.getElementById(layerId + '_color');
          if (cpElem) cpElem.value = newColor;
        } catch(e){}
      };

      // Helper: sync UI slider/number visuals with layer color
      function setSliderColorForLayer(layerId, color) {
        try {
          var rid = document.getElementById(layerId + '_range');
          var nid = document.getElementById(layerId + '_number');
          if (rid) {
            var min = parseFloat(rid.min) || 2, max = parseFloat(rid.max) || 30;
            var val = parseFloat(rid.value) || min;
            var pct = Math.round(((val - min) / (max - min)) * 100);
            rid.style.background = 'linear-gradient(90deg, ' + color + ' ' + pct + '%, #e6e6e6 ' + pct + '%)';
            rid.style.setProperty('--thumb-border', color);
            if (!rid._styledListener) {
              rid.addEventListener('input', function() {
                var v = parseFloat(this.value), p = Math.round(((v - min) / (max - min)) * 100), cp = color;
                var cpElem = document.getElementById(layerId + '_color');
                if (cpElem) cp = cpElem.value;
                this.style.background = 'linear-gradient(90deg, ' + cp + ' ' + p + '%, #e6e6e6 ' + p + '%)';
                this.style.setProperty('--thumb-border', cp);
                var num = document.getElementById(layerId + '_number');
                if (num) num.value = this.value;
              });
              rid._styledListener = true;
            }
          }
          if (nid) nid.style.borderColor = color;
        } catch (e) {}
      }

      // Global function to change marker radius/size
      window.changeLayerSize = function (layerId, newSize) {
        var targetLayer = null;
        for (var j = 0; j < overlaysTree.length; j++) {
          if (overlaysTree[j].id === layerId) {
            targetLayer = overlaysTree[j].layer;
            break;
          }
        }
        if (targetLayer) {
          try {
            targetLayer.eachLayer(function (l) {
              if (typeof l.setRadius === 'function') {
                l.setRadius(Number(newSize));
              } else if (l.setStyle) {
                l.setStyle({ radius: Number(newSize) });
              }
            });
          } catch (err) {
            if (typeof targetLayer.setStyle === 'function') {
              targetLayer.setStyle({ radius: Number(newSize) });
            }
          }
        }
      };

      var highlightLayer;
      function highlightFeature(e) {
        highlightLayer = e.target;
        highlightLayer.openPopup();
      }
      map = L.map("map", {
        zoomControl: false,
        maxZoom: 28,
        minZoom: 1,
      });
      hash = new L.Hash(map);
      map.attributionControl.setPrefix(
        '<a href="https://github.com/AFurqanHassan" target="_blank">Ahmad Furqan Hassan</a> &middot; <a href="https://punjab.gov.pk/wasa" target="_blank">WASA SKP</a>'
      );
      autolinker = new Autolinker({
        truncate: { length: 30, location: "smart" },
      });
      // remove popup's row if "visible-with-data"
      function removeEmptyRowsFromPopupContent(content, feature) {
        var tempDiv = document.createElement("div");
        tempDiv.innerHTML = content;
        var rows = tempDiv.querySelectorAll("tr");
        for (var i = 0; i < rows.length; i++) {
          var td = rows[i].querySelector("td.visible-with-data");
          var key = td ? td.id : "";
          if (
            td &&
            td.classList.contains("visible-with-data") &&
            feature.properties[key] == null
          ) {
            rows[i].parentNode.removeChild(rows[i]);
          }
        }
        return tempDiv.innerHTML;
      }
      // modify popup if contains media
      function addClassToPopupIfMedia(content, popup) {
        var tempDiv = document.createElement("div");
        tempDiv.innerHTML = content;
        var imgTd = tempDiv.querySelector("td img");
        if (imgTd) {
          var src = imgTd.getAttribute("src");
          if (/\.(jpg|jpeg|png|gif|bmp|webp|avif)$/i.test(src)) {
            popup._contentNode.classList.add("media");
            setTimeout(function () {
              popup.update();
            }, 10);
          } else if (/\.(mp3|wav|ogg|aac)$/i.test(src)) {
            var audio = document.createElement("audio");
            audio.controls = true;
            audio.src = src;
            imgTd.parentNode.replaceChild(audio, imgTd);
            popup._contentNode.classList.add("media");
            setTimeout(function () {
              popup.setContent(tempDiv.innerHTML);
              popup.update();
            }, 10);
          } else if (/\.(mp4|webm|ogg|mov)$/i.test(src)) {
            var video = document.createElement("video");
            video.controls = true;
            video.src = src;
            video.style.width = "400px";
            video.style.height = "300px";
            video.style.maxHeight = "60vh";
            video.style.maxWidth = "60vw";
            imgTd.parentNode.replaceChild(video, imgTd);
            popup._contentNode.classList.add("media");
            // Aggiorna il popup quando il video carica i metadati
            video.addEventListener("loadedmetadata", function () {
              popup.update();
            });
            setTimeout(function () {
              popup.setContent(tempDiv.innerHTML);
              popup.update();
            }, 10);
          } else {
            popup._contentNode.classList.remove("media");
          }
        } else {
          popup._contentNode.classList.remove("media");
        }
      }
      zoomControl = L.control
        .zoom({
          position: "topright",
        })
        .addTo(map);

      measureControl = new L.Control.Measure({
        position: "topright",
        primaryLengthUnit: "meters",
        secondaryLengthUnit: "kilometers",
        primaryAreaUnit: "sqmeters",
        secondaryAreaUnit: "hectares",
      });
      measureControl.addTo(map);

      var measureToggleElements = document.getElementsByClassName(
        "leaflet-control-measure-toggle"
      );
      if (measureToggleElements.length > 0) {
        var measureToggle = measureToggleElements[0];
        measureToggle.innerHTML = "";
        measureToggle.className += " fas fa-ruler";
      }
      bounds_group = new L.featureGroup([]);
      function setBounds() {
        map.setMaxBounds(map.getBounds());
        map.setMinZoom(map.getZoom());
      }
      map.createPane("pane_OSMStandard_0");
      map.getPane("pane_OSMStandard_0").style.zIndex = 400;
      var layer_OSMStandard_0 = L.tileLayer(
        "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          pane: "pane_OSMStandard_0",
          opacity: 1.0,
          attribution:
            '<a href="https://www.openstreetmap.org/copyright">© OpenStreetMap contributors</a>',
          minZoom: 1,
          maxZoom: 28,
          minNativeZoom: 0,
          maxNativeZoom: 19,
        }
      );
      layer_OSMStandard_0;
      map.addLayer(layer_OSMStandard_0);

      // Helper function to handle image loading errors and fallback
      function handleImageError(img, filename, linkId, errId) {
        // If we haven't tried the relative path yet
        if (!img.getAttribute("data-tried-relative")) {
          img.setAttribute("data-tried-relative", "true");
          var relativePath = "images/" + filename;
          console.log("Trying fallback path:", relativePath);
          img.src = relativePath;
          // Update the link to point to the relative path as well, so user can open it
          document.getElementById(linkId).href = relativePath;
          // Update the error text to show we are trying the fallback
          var errDiv = document.getElementById(errId);
          if (errDiv) {
            errDiv.innerHTML +=
              "<br><small>Trying local fallback: " + relativePath + "</small>";
          }
        } else {
          // If relative path also failed, show the error message
          img.style.display = "none";
          document.getElementById(errId).style.display = "block";
        }
      }

      function pop_ManholeCovers_1(feature, layer) {
        // Hover events removed to allow popup only on click
        var popupContent = "No Image available for this feature.";
        if (feature.properties["PICS"]) {
          var rawPath = String(feature.properties["PICS"])
            .trim()
            .replace(/\\/g, "/");
          var imgPath = rawPath;
          if (!imgPath.startsWith("http") && !imgPath.startsWith("file:///")) {
            // Attempt to fix local path if it looks like a drive letter
            if (/^[a-zA-Z]:/.test(imgPath)) {
              imgPath = "file:///" + imgPath;
            }
          }

          var filename = rawPath.replace(/^.*[\\\/]/, "");
          var linkId = "link-" + feature.properties["FID"];
          var errId = "err-" + feature.properties["FID"];

          // Improved alignment: Container handles size, image fills container
          popupContent =
            '<div style="min-width: 300px;">' +
            '<img src="' +
            imgPath +
            '" style="width: 100%; height: auto; display: block; border-radius: 4px;" ' +
            "onerror=\"handleImageError(this, '" +
            filename.replace(/'/g, "\\'") +
            "', '" +
            linkId +
            "', '" +
            errId +
            "')\" " +
            'alt="Loading image...">' +
            '<div id="' +
            errId +
            '" style="display:none; color:red; font-size:12px; margin-top:5px;">' +
            "<strong>Image not loaded</strong><br>" +
            "Path: " +
            imgPath +
            "</div>" +
            '<p style="margin: 8px 0 0 0; font-size: 13px; text-align: center;">' +
            '<a id="' +
            linkId +
            '" href="' +
            imgPath +
            '" target="_blank" style="text-decoration: none; color: #0078A8; font-weight: bold;">Open Image in New Tab</a>' +
            "</p>" +
            "</div>";
        }
        layer.bindPopup(popupContent, {
          maxHeight: 600,
          maxWidth: 500,
          minWidth: 300,
        });
      }

      function style_ManholeCovers_1_0() {
        return {
          pane: "pane_ManholeCovers_1",
          radius: defaultManholeRadius,
          opacity: 1,
          color: "rgba(35,35,35,1.0)",
          dashArray: "",
          lineCap: "butt",
          lineJoin: "miter",
          weight: 1,
          fill: true,
          fillOpacity: 1,
          fillColor: defaultManholeColor,
          interactive: true,
        };
      }
      map.createPane("pane_ManholeCovers_1");
      map.getPane("pane_ManholeCovers_1").style.zIndex = 401;
      map.getPane("pane_ManholeCovers_1").style["mix-blend-mode"] = "normal";
      var layer_ManholeCovers_1 = new L.geoJson(json_ManholeCovers_1, {
        attribution: "",
        interactive: true,
        dataVar: "json_ManholeCovers_1",
        layerName: "layer_ManholeCovers_1",
        pane: "pane_ManholeCovers_1",
        onEachFeature: pop_ManholeCovers_1,
        pointToLayer: function (feature, latlng) {
          var context = {
            feature: feature,
            variables: {},
          };
          return L.circleMarker(latlng, style_ManholeCovers_1_0(feature));
        },
      });

      // --- Point in Polygon Logic ---
      function isPointInPolygon(point, vs) {
        // ray-casting algorithm based on
        // https://github.com/substack/point-in-polygon
        var x = point[0], y = point[1];
        var inside = false;
        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          var xi = vs[i][0], yi = vs[i][1];
          var xj = vs[j][0], yj = vs[j][1];
          var intersect = ((yi > y) != (yj > y))
              && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // --- Optimized Categorization Logic ---
      
      // Pre-calculate Bounding Box & Constants
      var BUFFER_METERS = 200;
      var DEG_PER_METER = 1 / 111320; // Approx lat degree per meter
      var BUFFER_DEG = BUFFER_METERS * DEG_PER_METER;
      var BUFFER_DEG_SQ = BUFFER_DEG * BUFFER_DEG;

      // Prepare boundary polygons and their individual bounding boxes for fast filtering
      boundaryPolygons = [];
      polyBboxes = [];

      json_MCSKPZones_2.features.forEach(function(f){
        var coords = (f.geometry.type === 'MultiPolygon') ? f.geometry.coordinates : [f.geometry.coordinates];
        coords.forEach(function(poly){
          boundaryPolygons.push(poly);
          // Calculate bbox for each polygon
          var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          poly[0].forEach(function(coord){
            if(coord[0] < minX) minX = coord[0];
            if(coord[0] > maxX) maxX = coord[0];
            if(coord[1] < minY) minY = coord[1];
            if(coord[1] > maxY) maxY = coord[1];
          });
          polyBboxes.push({
            minX: minX - BUFFER_DEG, 
            minY: minY - BUFFER_DEG, 
            maxX: maxX + BUFFER_DEG, 
            maxY: maxY + BUFFER_DEG
          });
        });
      });

      function isPointInBBox(pt, bbox) {
        return pt[0] >= bbox.minX && pt[0] <= bbox.maxX && 
               pt[1] >= bbox.minY && pt[1] <= bbox.maxY;
      }

      function distSq(a, b) {
        var dx = a[0]-b[0], dy = b[1]-a[1];
        return dx*dx + dy*dy;
      }

      function fastIsPointInMultiPolygon(pt) {
        for (var k = 0; k < boundaryPolygons.length; k++) {
          // 1. Fast BBox check
          if (!isPointInBBox(pt, polyBboxes[k])) continue;
          
          // 2. Exact Polygon check
          var vs = boundaryPolygons[k][0];
          if (isPointInPolygon(pt, vs)) return true;
          
          // 3. Fast Euclidean Buffer check (approximation for speed)
          for (var i = 0; i < vs.length; i++) {
            if (distSq(pt, vs[i]) <= BUFFER_DEG_SQ) return true;
          }
        }
        return false;
      }


      // 2. Filter Unique Features & Split by Boundary
      uniqueFeatures = [];
      coordMap = {};
      
      totalInside = [];
      totalOutside = [];
      uniqueInside = [];
      uniqueOutside = [];
      
      json_ManholeCovers_1.features.forEach(function(feature){
        var pt = feature.geometry.coordinates; // [lon, lat]
        var coordStr = pt.join(',');
        var isInside = fastIsPointInMultiPolygon(pt);
        
        // Populate Total
        if(isInside) totalInside.push(feature);
        else totalOutside.push(feature);

        // Populate Unique
        if(!coordMap[coordStr]) {
            coordMap[coordStr] = true;
            uniqueFeatures.push(feature);
            if(isInside) uniqueInside.push(feature);
            else uniqueOutside.push(feature);
        }
      });

      // 3. Create LayerCollections
      json_ManholeCovers_Inside = { "type": "FeatureCollection", "features": totalInside };
      json_ManholeCovers_Outside = { "type": "FeatureCollection", "features": totalOutside };
      json_UniqueInside = { "type": "FeatureCollection", "features": uniqueInside };
      json_UniqueOutside = { "type": "FeatureCollection", "features": uniqueOutside };

      // Style function (reused, but distinct layers allow distinct defaults/overrides if we want)
      // --- Refactored Layer Management (Stable Objects) ---
      


      // Inside Layer (Persistent)
      layer_ManholeCovers_Inside = new L.geoJson(json_ManholeCovers_Inside, {
        attribution: "", interactive: true, dataVar: "json_ManholeCovers_Inside",
        layerName: "layer_ManholeCovers_Inside", pane: "pane_ManholeCovers_1",
        onEachFeature: pop_ManholeCovers_1,
        pointToLayer: function (feature, latlng) { return L.circleMarker(latlng, getActiveStyle(false)); },
      });
      bounds_group.addLayer(layer_ManholeCovers_Inside);
      map.addLayer(layer_ManholeCovers_Inside);

      // Outside Layer (Persistent)
      layer_ManholeCovers_Outside = new L.geoJson(json_ManholeCovers_Outside, {
        attribution: "", interactive: true, dataVar: "json_ManholeCovers_Outside",
        layerName: "layer_ManholeCovers_Outside", pane: "pane_ManholeCovers_1",
        onEachFeature: pop_ManholeCovers_1,
        pointToLayer: function (feature, latlng) { return L.circleMarker(latlng, getActiveStyle(true)); },
      });
      bounds_group.addLayer(layer_ManholeCovers_Outside);
      map.addLayer(layer_ManholeCovers_Outside);


      function pop_MCSKPZones_2(feature, layer) {
        layer.on({
          mouseout: function (e) {
            if (typeof layer.closePopup == "function") {
              layer.closePopup();
            } else {
              layer.eachLayer(function (feature) {
                feature.closePopup();
              });
            }
          },
          mouseover: highlightFeature,
        });
        var popupContent =
          '<table>\
                    <tr>\
                        <td colspan="2">' +
          (feature.properties["OBJECTID"] !== null
            ? autolinker.link(
                String(feature.properties["OBJECTID"])
                  .replace(/'/g, "'")
                  .toLocaleString()
              )
            : "") +
          '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' +
          (feature.properties["Distt_Name"] !== null
            ? autolinker.link(
                String(feature.properties["Distt_Name"])
                  .replace(/'/g, "'")
                  .toLocaleString()
              )
            : "") +
          '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' +
          (feature.properties["Shape_Leng"] !== null
            ? autolinker.link(
                String(feature.properties["Shape_Leng"])
                  .replace(/'/g, "'")
                  .toLocaleString()
              )
            : "") +
          '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' +
          (feature.properties["Shape_Area"] !== null
            ? autolinker.link(
                String(feature.properties["Shape_Area"])
                  .replace(/'/g, "'")
                  .toLocaleString()
              )
            : "") +
          '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' +
          (feature.properties["ZONE"] !== null
            ? autolinker.link(
                String(feature.properties["ZONE"])
                  .replace(/'/g, "'")
                  .toLocaleString()
              )
            : "") +
          "</td>\
                    </tr>\
                </table>";
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on("popupopen", function (e) {
          addClassToPopupIfMedia(content, e.popup);
        });
        layer.bindPopup(content, { maxHeight: 400 });
      }

      function style_MCSKPZones_2_0() {
        return {
          pane: "pane_MCSKPZones_2",
          opacity: 1,
          color: "rgba(35,35,35,1.0)",
          dashArray: "",
          lineCap: "butt",
          lineJoin: "miter",
          weight: 4.0,
          fillOpacity: 0,
          interactive: false,
        };
      }
      map.createPane("pane_MCSKPZones_2");
      map.getPane("pane_MCSKPZones_2").style.zIndex = 402;
      map.getPane("pane_MCSKPZones_2").style["mix-blend-mode"] = "normal";
      layer_MCSKPZones_2 = new L.geoJson(json_MCSKPZones_2, {
        attribution: "",
        interactive: false,
        dataVar: "json_MCSKPZones_2",
        layerName: "layer_MCSKPZones_2",
        pane: "pane_MCSKPZones_2",
        onEachFeature: pop_MCSKPZones_2,
        style: style_MCSKPZones_2_0,
      });
      bounds_group.addLayer(layer_MCSKPZones_2);
      map.addLayer(layer_MCSKPZones_2);
      map.fitBounds(layer_MCSKPZones_2.getBounds());
      var overlaysTree = [
        {
          label: '<img src="legend/MCSKPZones_2.png" /> MC SKP Zones',
          layer: layer_MCSKPZones_2,
        },
        {
          id: 'ManholeCovers_Inside',
          label: '<div class="layer-row-container">' +
                   '<div class="layer-label-top">' +
                     '<div class="layer-label-group">' +
                       '<span class="leaflet-layerstree-header-name" id="label_inside">Inside Boundary (' + totalInside.length + ')</span>' +
                     '</div>' +
                   '</div>' +
                   '<div class="layer-controls">' +
                     '<div class="layer-color-picker-wrapper">' +
                       '<input type="color" id="ManholeCovers_Inside_color" class="layer-color-picker" value="' + defaultManholeColor + '" onchange="changeLayerColor(\'ManholeCovers_Inside\', this.value)" title="Change Layer Color">' +
                     '</div>' +
                     '<input type="range" id="ManholeCovers_Inside_range" min="2" max="30" step="0.5" value="' + defaultManholeRadius + '" oninput="document.getElementById(\'ManholeCovers_Inside_number\').value=this.value" onchange="changeLayerSize(\'ManholeCovers_Inside\', this.value)" title="Change Marker Size">' +
                     '<input type="number" id="ManholeCovers_Inside_number" min="2" max="30" step="0.5" value="' + defaultManholeRadius + '" onchange="changeLayerSize(\'ManholeCovers_Inside\', this.value); document.getElementById(\'ManholeCovers_Inside_range\').value=this.value">' +
                   '</div>' +
                 '</div>',
          layer: layer_ManholeCovers_Inside,
        },
        {
          id: 'ManholeCovers_Outside',
          label: '<div class="layer-row-container">' +
                   '<div class="layer-label-top">' +
                     '<div class="layer-label-group">' +
                       '<span class="leaflet-layerstree-header-name" id="label_outside">Outside Boundary (' + totalOutside.length + ')</span>' +
                     '</div>' +
                   '</div>' +
                   '<div class="layer-controls">' +
                     '<div class="layer-color-picker-wrapper">' +
                       '<input type="color" id="ManholeCovers_Outside_color" class="layer-color-picker" value="#555555" onchange="changeLayerColor(\'ManholeCovers_Outside\', this.value)" title="Change Layer Color">' +
                     '</div>' +
                     '<input type="range" id="ManholeCovers_Outside_range" min="2" max="30" step="0.5" value="' + defaultManholeRadius + '" oninput="document.getElementById(\'ManholeCovers_Outside_number\').value=this.value" onchange="changeLayerSize(\'ManholeCovers_Outside\', this.value)" title="Change Marker Size">' +
                     '<input type="number" id="ManholeCovers_Outside_number" min="2" max="30" step="0.5" value="' + defaultManholeRadius + '" onchange="changeLayerSize(\'ManholeCovers_Outside\', this.value); document.getElementById(\'ManholeCovers_Outside_range\').value=this.value">' +
                   '</div>' +
                 '</div>',
          layer: layer_ManholeCovers_Outside,
        },
        { label: "OSM Standard", layer: layer_OSMStandard_0, radioGroup: "bm" },
      ];
      var lay = L.control.layers.tree(null, overlaysTree, {
        collapsed: false,
      });
      lay.addTo(map);
      // Move layers control to sidebar
      var layersContainer = lay.getContainer();
      document.getElementById("layers-control").appendChild(layersContainer);
      
      // initialize slider visuals to match color pickers (allow time for Leaflet Tree to render)
      setTimeout(function(){
        try {
          updateToggleView('total'); // Force initial visibility state first
          
          setSliderColorForLayer('ManholeCovers_Inside', defaultManholeColor);
          setSliderColorForLayer('ManholeCovers_Outside', '#555555');
          setSliderColorForLayer('Unique_Inside', '#00D1FF');
          setSliderColorForLayer('Unique_Outside', '#0084A1');
          
          document.querySelectorAll('.layer-color-picker').forEach(function(cp){
            if (!cp.id) return;
            var lid = cp.id.replace('_color','');
            setSliderColorForLayer(lid, cp.value);
          });
          setTimeout(function(){ updateToggleView('total'); }, 100);
        } catch (err) {
          console.error("Layer init timeout error:", err);
        }
      }, 500);
    } catch (err) {
      console.error("Critical app initialization error:", err);
      var layersDiv = document.getElementById("layers-control");
      if (layersDiv) layersDiv.innerHTML = '<div style="color:red;font-size:11px;padding:10px;">Error initializing layers. Refer console.</div>';
    }
  }



      // Dynamic Style Logic
      function getActiveStyle(isOutside) {
        var toggle = document.getElementById('view-toggle');
        var isUnique = toggle && toggle.classList.contains('unique-active');
        if (isOutside) {
          var rOut = document.getElementById('ManholeCovers_Outside_range');
          return {
            pane: "pane_ManholeCovers_1",
            radius: rOut ? parseFloat(rOut.value) : defaultManholeRadius,
            opacity: 1, color: "rgba(35,35,35,1.0)", weight: 1, fill: true, fillOpacity: 1,
            fillColor: isUnique ? modeColors.unique.ManholeCovers_Outside : modeColors.total.ManholeCovers_Outside,
            interactive: true,
          };
        } else {
          var rIn = document.getElementById('ManholeCovers_Inside_range');
          return {
            pane: "pane_ManholeCovers_1",
            radius: rIn ? parseFloat(rIn.value) : defaultManholeRadius,
            opacity: 1, color: "rgba(35,35,35,1.0)", weight: 1, fill: true, fillOpacity: 1,
            fillColor: isUnique ? modeColors.unique.ManholeCovers_Inside : modeColors.total.ManholeCovers_Inside,
            interactive: true,
          };
        }
      }

      // Toggle View Logic
      function updateToggleView(view) {
        var container = document.getElementById('view-toggle');
        if (!container) return;
        var options = container.querySelectorAll('.toggle-option');
        
        options.forEach(function(opt) {
          opt.classList.toggle('active', opt.dataset.view === view);
        });

        if (view === 'unique') {
          container.classList.add('unique-active');
          // Update Persistent layers with Unique data
          if (typeof layer_ManholeCovers_Inside !== 'undefined') {
            layer_ManholeCovers_Inside.clearLayers();
            layer_ManholeCovers_Inside.addData(json_UniqueInside);
          }
          if (typeof layer_ManholeCovers_Outside !== 'undefined') {
            layer_ManholeCovers_Outside.clearLayers();
            layer_ManholeCovers_Outside.addData(json_UniqueOutside);
          }

          var l_in = document.getElementById('label_inside');
          var l_out = document.getElementById('label_outside');
          if(l_in) l_in.textContent = 'Inside Boundary (' + uniqueInside.length + ')';
          if(l_out) l_out.textContent = 'Outside Boundary (' + uniqueOutside.length + ')';
          
          // Restore Unique colors from state
          changeLayerColor('ManholeCovers_Inside', modeColors.unique.ManholeCovers_Inside);
          changeLayerColor('ManholeCovers_Outside', modeColors.unique.ManholeCovers_Outside);
        } else {
          container.classList.remove('unique-active');
          // Restore Total data
          if (typeof layer_ManholeCovers_Inside !== 'undefined') {
            layer_ManholeCovers_Inside.clearLayers();
            layer_ManholeCovers_Inside.addData(json_ManholeCovers_Inside);
          }
          if (typeof layer_ManholeCovers_Outside !== 'undefined') {
            layer_ManholeCovers_Outside.clearLayers();
            layer_ManholeCovers_Outside.addData(json_ManholeCovers_Outside);
          }

          var l_in = document.getElementById('label_inside');
          var l_out = document.getElementById('label_outside');
          if(l_in) l_in.textContent = 'Inside Boundary (' + totalInside.length + ')';
          if(l_out) l_out.textContent = 'Outside Boundary (' + totalOutside.length + ')';
          
          // Restore Total colors from state
          changeLayerColor('ManholeCovers_Inside', modeColors.total.ManholeCovers_Inside);
          changeLayerColor('ManholeCovers_Outside', modeColors.total.ManholeCovers_Outside);
        }
      }

      document.getElementById('view-toggle').addEventListener('click', function(e) {
        var opt = e.target.closest('.toggle-option');
        if (opt) {
          updateToggleView(opt.dataset.view);
        }
      });

      // Sidebar Toggle Logic
      document
        .getElementById("sidebar-toggle")
        .addEventListener("click", function () {
          document.getElementById("sidebar").classList.toggle("active");
        });

      // Update file names in upload section
      document
        .getElementById("csvFile")
        .addEventListener("change", function (e) {
          var name =
            e.target.files.length > 0
              ? e.target.files[0].name
              : "No file selected";
          document.getElementById("csv-name").innerText = name;
        });
      document
        .getElementById("imgFiles")
        .addEventListener("change", function (e) {
          var count = e.target.files.length;
          document.getElementById("img-count").innerText =
            count + " images selected";
        });

      // Global function for dynamic layer removal
      window.removeDynamicLayer = function (layerId) {
        var index = -1;
        var targetLayer = null;
        for (var j = 0; j < overlaysTree.length; j++) {
          if (overlaysTree[j].id === layerId) {
            index = j;
            targetLayer = overlaysTree[j].layer;
            break;
          }
        }

        if (index > -1) {
          if (targetLayer) map.removeLayer(targetLayer);
          overlaysTree.splice(index, 1);
          if (lay) {
            lay.setOverlayTree(overlaysTree);
            var toggles = document.querySelectorAll(
              ".leaflet-control-layers-toggle"
            );
            toggles.forEach(function (t) {
              t.style.display = "none";
            });
          }
        }
      };
      setBounds();
      var i = 0;
      layer_MCSKPZones_2.eachLayer(function (layer) {
        var context = {
          feature: layer.feature,
          variables: {},
        };
        layer.bindTooltip(
          layer.feature.properties["ZONE"] !== null
            ? String(
                "<div style=\"color: #eb1b1b; font-size: 14pt; font-weight: bold; font-family: 'Open Sans', sans-serif;\">" +
                  layer.feature.properties["ZONE"]
              ) + "</div>"
            : "",
          { permanent: true, offset: [-0, -16], className: "css_MCSKPZones_2" }
        );
        labels.push(layer);
        totalMarkers += 1;
        layer.added = true;
        addLabel(layer, i);
        i++;
      });
      resetLabels([layer_MCSKPZones_2]);
      map.on("zoomend", function () {
        resetLabels([layer_MCSKPZones_2]);
      });
      map.on("layeradd", function () {
        resetLabels([layer_MCSKPZones_2]);
      });
      map.on("layerremove", function () {
        resetLabels([layer_MCSKPZones_2]);
      });

      // CSV and Image Upload Logic
      document
        .getElementById("uploadBtn")
        .addEventListener("click", function () {
          var csvInput = document.getElementById("csvFile");
          var imgInput = document.getElementById("imgFiles");
          var status = document.getElementById("uploadStatus");

          if (!csvInput.files.length) {
            alert("Please select a CSV file.");
            return;
          }

          status.innerHTML = "Processing...";

          // Map image names to Blob URLs
          var imagesMap = new Map();
          for (var i = 0; i < imgInput.files.length; i++) {
            var file = imgInput.files[i];
            imagesMap.set(file.name, URL.createObjectURL(file));
          }

          var reader = new FileReader();
          var fileName = csvInput.files[0].name.replace(/\.[^/.]+$/, ""); // Strip extension

          reader.onload = function (e) {
            var text = e.target.result;
            var lines = text.split(/\r?\n/);
            var headers = lines[0].toLowerCase().split(",");

            var latIdx = headers.indexOf("latitude");
            if (latIdx === -1) latIdx = headers.indexOf("lat");
            var lonIdx = headers.indexOf("longitude");
            if (lonIdx === -1) lonIdx = headers.indexOf("lon");
            if (lonIdx === -1) lonIdx = headers.indexOf("lng");
            var picsIdx = headers.indexOf("pics");

            if (latIdx === -1 || lonIdx === -1) {
              alert("CSV must contain latitude and longitude columns.");
              status.innerHTML = "Error: Missing columns.";
              return;
            }

            var features = [];
            for (var i = 1; i < lines.length; i++) {
              if (!lines[i].trim()) continue;
              var cols = lines[i].split(",");
              var lat = parseFloat(cols[latIdx]);
              var lon = parseFloat(cols[lonIdx]);
              var picName = picsIdx !== -1 ? cols[picsIdx].trim() : "";

              if (!isNaN(lat) && !isNaN(lon)) {
                var blobUrl = imagesMap.get(picName) || "";
                features.push({
                  type: "Feature",
                  properties: {
                    FID: "upload-" + fileName + "-" + i,
                    PICS: blobUrl,
                    OriginalPic: picName,
                  },
                  geometry: {
                    type: "Point",
                    coordinates: [lon, lat],
                  },
                });
              }
            }

            if (features.length > 0) {
              var uploadGeoJson = {
                type: "FeatureCollection",
                features: features,
              };

              // Pick next color from palette
              var defaultColor = colorPalette[colorIndex % colorPalette.length];
              colorIndex++;

              var layer_Uploaded = new L.geoJson(uploadGeoJson, {
                interactive: true,
                onEachFeature: pop_ManholeCovers_1,
                pointToLayer: function (feature, latlng) {
                  return L.circleMarker(latlng, {
                    radius: 7,
                    fillColor: defaultColor,
                    color: "#000",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8,
                  });
                },
              });

              // Add to map and zoom
              layer_Uploaded.addTo(map);
              map.fitBounds(layer_Uploaded.getBounds());

              // Add to layers section with unique ID, Color Picker and Removal button
              if (lay) {
                var uniqueId = "dyn_" + Date.now();
                var labelHTML =
                  '<div class="layer-row-container">' +
                    '<div class="layer-label-top">' +
                      '<div class="layer-label-group">' +
                        '<span class="leaflet-layerstree-header-name">' + fileName + ' (' + features.length + ')</span>' +
                      '</div>' +
                      '<i class="fas fa-trash-alt remove-layer-btn" onclick="removeDynamicLayer(\'' + uniqueId + '\'); event.stopPropagation();" title="Remove Layer"></i>' +
                    '</div>' +
                    '<div class="layer-controls">' +
                      '<div class="layer-color-picker-wrapper">' +
                        '<input type="color" class="layer-color-picker" id="' + uniqueId + '_color" value="' + defaultColor + '" onchange="changeLayerColor(\'' + uniqueId + '\', this.value)" title="Change Layer Color">' +
                      '</div>' +
                      '<input type="range" id="' + uniqueId + '_range" min="2" max="30" step="0.5" value="7" oninput="document.getElementById(\'' + uniqueId + '_number\').value=this.value" onchange="changeLayerSize(\'' + uniqueId + '\', this.value)" title="Change Marker Size">' +
                      '<input type="number" id="' + uniqueId + '_number" min="2" max="30" step="0.5" value="7" onchange="changeLayerSize(\'' + uniqueId + '\', this.value); document.getElementById(\'' + uniqueId + '_range\').value=this.value">' +
                    '</div>' +
                  '</div>';

                overlaysTree.push({
                  id: uniqueId,
                  label: labelHTML,
                  layer: layer_Uploaded,
                });

                lay.setOverlayTree(overlaysTree);

                // Re-hide toggle icons
                var toggles = document.querySelectorAll(
                  ".leaflet-control-layers-toggle"
                );
                toggles.forEach(function (t) {
                  t.style.display = "none";
                });
                // initialize slider visuals for this new layer
                setTimeout(function(){ try{ setSliderColorForLayer(uniqueId, defaultColor); }catch(e){} }, 30);
              }

              status.innerHTML = "Loaded " + features.length + " points.";
            } else {
              status.innerHTML = "No valid data found.";
            }
          };
          reader.readAsText(csvInput.files[0]);
        });

      // Debug: indicate script loaded and map objects created
      if (typeof map !== 'undefined') {
        map.whenReady(function(){ console.log('Map initialized (whenReady)'); });
      } else {
        console.log('Map object not defined at end of script');
      }
    </script>
    <script>
      (function(){
        // Respect reduced motion
        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

        var sidebar = document.getElementById('sidebar');
        if (!sidebar) return;

        // Initialize variables so CSS has defaults
        sidebar.style.setProperty('--mouse-x', '50%');
        sidebar.style.setProperty('--mouse-y', '50%');

        function onMove(e){
          var ev = e.touches && e.touches[0] ? e.touches[0] : e;
          var rect = sidebar.getBoundingClientRect();
          var x = Math.max(0, Math.min(1, (ev.clientX - rect.left) / rect.width));
          var y = Math.max(0, Math.min(1, (ev.clientY - rect.top) / rect.height));
          sidebar.style.setProperty('--mouse-x', (x*100).toFixed(2) + '%');
          sidebar.style.setProperty('--mouse-y', (y*100).toFixed(2) + '%');
          // Slight parallax transform for the blob layer
          var px = (x - 0.5) * 12; // px movement range
          var py = (y - 0.5) * 8;
          sidebar.style.setProperty('--blob-translate', px + 'px ' + py + 'px');
        }

        sidebar.addEventListener('mousemove', onMove);
        sidebar.addEventListener('touchmove', onMove, {passive:true});
        sidebar.addEventListener('mouseleave', function(){
          sidebar.style.setProperty('--mouse-x', '50%');
          sidebar.style.setProperty('--mouse-y', '50%');
          sidebar.style.setProperty('--blob-translate', '0px 0px');
        });
      })();
    </script>
    <script>
      // Background starfield + subtle particles
      (function(){
        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

        var starsCanvas = document.getElementById('bg-stars');
        var partCanvas = document.getElementById('bg-particles');
        if (!starsCanvas || !partCanvas) return;

        var sctx = starsCanvas.getContext('2d');
        var pctx = partCanvas.getContext('2d');

        var DPR = Math.max(1, window.devicePixelRatio || 1);
        function resize(){
          var w = window.innerWidth;
          var h = window.innerHeight;
          starsCanvas.width = w * DPR; starsCanvas.height = h * DPR;
          starsCanvas.style.width = w + 'px'; starsCanvas.style.height = h + 'px';
          partCanvas.width = w * DPR; partCanvas.height = h * DPR;
          partCanvas.style.width = w + 'px'; partCanvas.style.height = h + 'px';
          sctx.setTransform(DPR,0,0,DPR,0,0);
          pctx.setTransform(DPR,0,0,DPR,0,0);
        }

        var stars = [];
        function initStars(){
          stars = [];
          var area = window.innerWidth * window.innerHeight;
          var count = Math.round(Math.min(800, Math.max(80, area / 8000)));
          for(var i=0;i<count;i++){
            stars.push({
              x: Math.random()*window.innerWidth,
              y: Math.random()*window.innerHeight*0.7, // mostly upper
              r: Math.random()*1.6 + 0.2,
              alpha: Math.random()*0.9 + 0.1,
              phase: Math.random()*Math.PI*2,
              speed: Math.random()*0.004 + 0.002
            });
          }
        }

        var particles = [];
        function initParticles(){
          particles = [];
          for(var i=0;i<20;i++){
            particles.push({
              x: Math.random()*window.innerWidth,
              y: window.innerHeight*0.65 + Math.random()*window.innerHeight*0.3,
              vx: (Math.random()*0.6-0.3),
              vy: (Math.random()*0.2-0.1),
              r: Math.random()*3+1,
              alpha: Math.random()*0.6+0.15
            });
          }
        }

        function draw(now){
          sctx.clearRect(0,0,window.innerWidth,window.innerHeight);
          pctx.clearRect(0,0,window.innerWidth,window.innerHeight);

          // stars
          for(var i=0;i<stars.length;i++){
            var st = stars[i];
            st.phase += st.speed * 1.5;
            var a = st.alpha * (0.6 + 0.4 * Math.sin(st.phase));
            sctx.beginPath();
            sctx.fillStyle = 'rgba(255,255,255,' + a.toFixed(3) + ')';
            sctx.arc(st.x, st.y, st.r, 0, Math.PI*2);
            sctx.fill();
          }

          // subtle moving lights on horizon/water
          for(var j=0;j<particles.length;j++){
            var p = particles[j];
            p.x += p.vx;
            p.y += Math.sin((now/1000 + j) * 0.5) * 0.2 + p.vy;
            if(p.x < -50) p.x = window.innerWidth + 50;
            if(p.x > window.innerWidth + 50) p.x = -50;
            if(p.y < window.innerHeight*0.6) p.y = window.innerHeight*0.6 + Math.random()*50;
            pctx.beginPath();
            pctx.fillStyle = 'rgba(180,230,255,' + (p.alpha * 0.9).toFixed(2) + ')';
            pctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
            pctx.fill();
            // reflection blur under
            pctx.beginPath();
            pctx.fillStyle = 'rgba(180,230,255,' + (p.alpha*0.08).toFixed(3) + ')';
            pctx.ellipse(p.x, p.y + 10, p.r*2.4, p.r*0.8, 0, 0, Math.PI*2);
            pctx.fill();
          }

          requestAnimationFrame(draw);
        }

        function start(){
          resize();
          initStars();
          initParticles();
          requestAnimationFrame(draw);
        }

        window.addEventListener('resize', function(){ resize(); initStars(); initParticles(); });
        // start after small delay so layout stabilizes
        setTimeout(start, 80);
      })();
    </script>
    <script>
      // Sidebar Particle Animation
      (function() {
        const canvas = document.getElementById('sidebar-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        let width, height;
        let particles = [];
        let animationId;
        let mouse = { x: null, y: null, radius: 100 };
        
        const config = {
          count: 350,
          minRadius: 1.5,
          maxRadius: 4.5,
          minSpeed: 0.2,
          maxSpeed: 0.9,
          color: 'rgba(255, 255, 255, '
        };
        
        class Particle {
          constructor() {
            this.init();
          }
          
          init() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.radius = config.minRadius + Math.random() * (config.maxRadius - config.minRadius);
            this.vx = (Math.random() - 0.5) * config.maxSpeed;
            this.vy = (Math.random() - 0.5) * config.maxSpeed;
            this.alpha = 0.2 + Math.random() * 0.5;
            this.baseAlpha = this.alpha;
            this.phase = Math.random() * Math.PI * 2;
          }
          
          update() {
            this.x += this.vx;
            this.y += this.vy;
            
            // Floating effect
            this.x += Math.sin(Date.now() * 0.001 + this.phase) * 0.1;
            this.y += Math.cos(Date.now() * 0.0008 + this.phase) * 0.1;
            
            // Mouse interaction
            if (mouse.x !== null && mouse.y !== null) {
              const dx = mouse.x - this.x;
              const dy = mouse.y - this.y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if (dist < mouse.radius) {
                const force = (mouse.radius - dist) / mouse.radius;
                this.x -= dx * force * 0.03;
                this.y -= dy * force * 0.03;
                this.alpha = Math.min(1, this.baseAlpha + force * 0.5);
              } else {
                this.alpha = this.baseAlpha;
              }
            } else {
              this.alpha = this.baseAlpha;
            }
            
            // Bounds check with wrap-around
            if (this.x < -10) this.x = width + 10;
            if (this.x > width + 10) this.x = -10;
            if (this.y < -10) this.y = height + 10;
            if (this.y > height + 10) this.y = -10;
          }
          
          draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = config.color + this.alpha + ')';
            ctx.fill();
            
            // Tiny glow for larger particles
            if (this.radius > 1.5) {
              ctx.shadowBlur = 4;
              ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';
            } else {
              ctx.shadowBlur = 0;
            }
          }
        }
        
        function resize() {
          const rect = canvas.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          canvas.width = rect.width * window.devicePixelRatio;
          canvas.height = rect.height * window.devicePixelRatio;
          ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
          width = rect.width;
          height = rect.height;
        }
        
        function init() {
          resize();
          particles = [];
          for (let i = 0; i < config.count; i++) {
            particles.push(new Particle());
          }
        }
        
        function animate() {
          ctx.clearRect(0, 0, width, height);
          
          particles.forEach(p => {
            p.update();
            p.draw();
          });
          
          animationId = requestAnimationFrame(animate);
        }
        
        const sidebar = document.getElementById('sidebar');
        if (sidebar) {
          sidebar.addEventListener('mousemove', (e) => {
            const rect = sidebar.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
          });
          
          sidebar.addEventListener('mouseleave', () => {
            mouse.x = null;
            mouse.y = null;
          });
        }
        
        window.addEventListener('resize', () => {
          resize();
          // Redistribution happens on init, but we can just keep them moving
        });
        
        if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          init();
          animate();
        }
        
        window.addEventListener('beforeunload', () => {
          if (animationId) cancelAnimationFrame(animationId);
        });
      })();
    </script>
  </body>
</html>
